# -*- coding: utf-8 -*-
"""question.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y-2xTahT8ucQGeaCuFECddOlqrmjsWmr
"""

import random

class Question:
    def __init__(self, qtype=None):
        self.qtype = qtype
        self.description = ""
        self.answer_options = []
        self.correct_answer = None
        self.marks = None

    def set_type(self, qt):
        valid_types = ['single', 'multiple', 'short', 'end']
        if qt in valid_types:
            self.qtype = qt
            return True
        else:
            return False

    def set_description(self, desc):
        if self.qtype == 'end':
            return False
        if isinstance(desc, str) and desc.strip() != "":
            self.description = desc
            return True
        return False

    def set_correct_answer(self, ans):
        if self.qtype == 'end':
            return False
        if isinstance(ans, str):
            if self.qtype == 'single' and ans in ['A', 'B', 'C', 'D']:
                self.correct_answer = ans
                return True
            elif self.qtype == 'multiple':
                options = ans.split(', ')
                if all(option in ['A', 'B', 'C', 'D'] for option in options):
                    self.correct_answer = ans
                    return True
        return False

    def set_answer_options(self, opts):
        if self.qtype in ['short', 'end']:
            self.answer_options = []
            return True

        if not isinstance(opts, list):
            return False

        valid_options = ['A.', 'B.', 'C.', 'D.']
        if all(isinstance(option, tuple) and len(option) == 2 and option[0].startswith(tuple(valid_options)) and option[1] in [True, False] for option in opts):
            self.answer_options = opts
            self._update_correct_answer()
            return True

        return False


    def set_marks(self, mark):
        if self.qtype == 'end':
            return False
        if isinstance(mark, int) and mark >= 0:
            self.marks = mark
            return True
        return False

    def get_answer_option_descriptions(self):
        if self.qtype in ['short', 'end']:
            return ""
        return "\n".join([option[0] for option in self.answer_options])

    def preview_question(self, question_number):
        if self.qtype == 'end':
            return f"Question {question_number} - End"
        return f"Question {question_number} - {self.qtype} Answer[{self.marks}]\n{self.description}\n{self.get_answer_option_descriptions()}\nExpected Answer: {self.correct_answer}"

    def shuffle_answers(self):
        if self.qtype == 'multiple':
            order = self.generate_order()
            self.answer_options = [self.answer_options[i] for i in order]
            self.correct_answer = ', '.join([['A', 'B', 'C', 'D'][i] for i in order])

    def generate_order(self):
        order = []
        while len(order) < 4:
            num = random.randint(0, 3)
            if num not in order:
                order.append(num)
        return order

    def _update_correct_answer(self):
        correct_options = [option[0] for option in self.answer_options if option[1] is True]
        self.correct_answer = ', '.join(correct_options)
    def mark_response(self, response):
        if self.qtype == 'end':
            return None

        if self.qtype == 'single':
            return self._mark_single_response(response)
        elif self.qtype == 'multiple':
            return self._mark_multiple_response(response)
        elif self.qtype == 'short':
            return self._mark_short_response(response)

    def _mark_single_response(self, response):
        if response == self.correct_answer:
            return round(self.marks, 2)
        return 0.0

    def _mark_multiple_response(self, response):
        if set(response.split(', ')) == set(self.correct_answer.split(', ')):
            return round(self.marks, 2)
        return 0.0

    def _mark_short_response(self, response):
        # Implement your own logic to mark short answer questions if needed.
        # Return 0.0 by default.
        return 0.0